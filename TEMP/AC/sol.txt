1. heap vs stack
stack is faster than heap
stack: local variable, system assigns memory automatically
heap: new or malloc, programmers assign memory manually, and need manually release

=================================================

2. mutex
A mutex is a lockable object that is designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently and access the same memory locations.

=================================================

3. Virtual memory
Virtual memory is a memory management technique that is implemented using both hardware and software. It maps memory addresses used by a program, into physical addresses in computer memory.
For each process, the virtual memory appears as a contiguous address space. But in real memory, it may not contiguous. The operating system manages virtual address spaces and the assignment of real memory to virtual memory.

=================================================

4. Overriding and Overloading
Overloading is when you define two methods with the same name, in the same class, distinguished by their signatures.
Overriding is when you redefine a method that has already been defined in a parent class with the same signature.

=================================================

5. Cache
A hardware or software component that stores data so future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation, or the duplicate of data stored elsewhere. 
CPU <==> cache <==> memory


=================================================

6. Fork
Fork is used to create a process.

int nums[SIZE] = {0, 1, 2, 3, 4};

int main()
{
  int i;
  pid_t pid;

  pid = fork();

  if (pid == 0) {
    for (i = 0; i < SIZE; i++) {
      nums[i] *= -i;
      printf("CHILD: %d ", nums[i]); /* LINE X */
    }
  } else if (pid > 0) {
    wait(NULL);
    for (i = 0; i < SIZE; i++)
      printf("PARENT: %d ", nums[i]); /* LINE Y */
  }

  return 0;
}

=================================================

7. Generator
Assigns the value returned by successive calls to gen to the elements in the range [first,last).
    int RandomNumber () { return (std::rand()%100); }
    std::srand ( unsigned ( std::time(0) ) );
    std::vector<int> myvector (8);
    std::generate (myvector.begin(), myvector.end(), RandomNumber);

=================================================

8. Decorator
A design pattern that allows behavior to be added to an individual object.
Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.
https://en.wikipedia.org/wiki/Decorator_pattern

Dynamic Decorator

struct Shape
{
  virtual string str() = 0;
};
struct Circle : Shape
{
  float radius;
  void resize(float factor) { radius *= factor; }
  string str() override
  {
    return string("A circle of radius") + to_string(radius);
  }
};
struct ColoredShape : Shape
{
  string color;
  Shape& shape;
  string str() override
  {
    return shape.str() + string(" which is ") + color;
  }
};

// usage:
Circle c{123};
ColoredShape cc{"red", c};
cout << cc.str() << endl;
// cannot call this:
cc.resize(1.2); // not part of ColoredShape

=================================================

9. C++ 11 lambda
A convenient way of defining an anonymous function object right at the location where it is invoked or passed as an argument to a function. 

#include <algorithm>  
#include <cmath>  
  
void abssort(float* x, unsigned n) {  
    std::sort(x, x + n,  
        // Lambda expression begins  
        [](float a, float b) {  
            return (std::abs(a) < std::abs(b));  
        } // end of lambda expression  
    );  
}

=================================================

10. 1 ~ 10,0000 has total 6561 numbers without '5'.
1 ~ 10,000 => 0 ~ 9999
0 ~ 9:      1
0 ~ 99:     10 + 1 * 9 = 19
0 ~ 999:    100 + 19 * 9 = 271
0 ~ 9999:   1000 + 271 * 9 = 6561


